% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ancova.R
\name{ancova_m_groups}
\alias{ancova_m_groups}
\title{Multi-Group Analysis of Covariance}
\usage{
ancova_m_groups(
  data,
  vars,
  visits = NULL,
  weights = c("counterfactual", "equal", "proportional_em", "proportional")
)
}
\arguments{
\item{data}{A \code{data.frame} containing the data to be used in the model.}

\item{vars}{A \code{vars} object as generated by \code{\link[=set_vars]{set_vars()}}. Only the \code{group},
\code{visit}, \code{outcome} and \code{covariates} elements are required. See details.}

\item{visits}{An optional character vector specifying which visits to
fit the ancova model at. If \code{NULL}, a separate ancova model will be fit to the
outcomes for each visit (as determined by \code{unique(data[[vars$visit]])}).
See details.}

\item{weights}{Character, either \code{"counterfactual"} (default), \code{"equal"},
\code{"proportional_em"} or \code{"proportional"}.
Specifies the weighting strategy to be used when calculating the lsmeans.
See the weighting section for more details.}
}
\description{
Performs an analysis of covariance with support for multiple treatment groups,
returning treatment effects (contrasts between each non-reference group and the
reference group) and least square means estimates for all groups.
}
\details{
This function extends \code{\link[=ancova]{ancova()}} to support more than two treatment groups.
The function works as follows:
\enumerate{
\item Select the first value from \code{visits}.
\item Subset the data to only the observations that occurred on this visit.
\item Fit a linear model as \code{vars$outcome ~ vars$group + vars$covariates}.
\item Extract treatment effects (each non-reference group vs reference) and
least square means for all treatment groups.
\item Repeat for all other values in \code{visits}.
}

The reference group is determined by the first factor level of \code{vars$group}.
Only pairwise comparisons between each non-reference group and the reference
group are computed (not all pairwise comparisons between groups).
}
\section{Output Structure}{

Results are returned as a named list with elements suffixed by visit name:

\if{html}{\out{<div class="sourceCode">}}\preformatted{list(
    trt_L1_L0_visit_1 = list(est = ...), # Group L1 vs L0 (reference)
    trt_L2_L0_visit_1 = list(est = ...), # Group L2 vs L0 (reference)
    lsm_L0_visit_1 = list(est = ...),    # LSMean for reference group L0
    lsm_L1_visit_1 = list(est = ...),    # LSMean for group L1
    lsm_L2_visit_1 = list(est = ...),    # LSMean for group L2
    ...
)
}\if{html}{\out{</div>}}

Group levels are standardized to "L0", "L1", "L2", etc., where "L0" represents
the reference group (first factor level).
}

\section{Weighting}{

\subsection{Counterfactual}{

For \code{weights = "counterfactual"} (the default) the lsmeans are obtained by
taking the average of the predicted values for each patient after assigning all patients
to each arm in turn.
This approach is equivalent to standardization or g-computation.
In comparison to \code{emmeans} this approach is equivalent to:

\if{html}{\out{<div class="sourceCode">}}\preformatted{emmeans::emmeans(model, specs = "<treatment>", counterfactual = "<treatment>")
}\if{html}{\out{</div>}}

Note that to ensure backwards compatibility with previous versions of \code{rbmi}
\code{weights = "proportional"} is an alias for \code{weights = "counterfactual"}.
To get results consistent with \code{emmeans}'s \code{weights = "proportional"}
please use \code{weights = "proportional_em"}.
}

\subsection{Equal}{

For \code{weights = "equal"} the lsmeans are obtained by taking the model fitted
value of a hypothetical patient whose covariates are defined as follows:
\itemize{
\item Continuous covariates are set to \code{mean(X)}
\item Dummy categorical variables are set to \code{1/N} where \code{N} is the number of levels
\item Continuous * continuous interactions are set to \code{mean(X) * mean(Y)}
\item Continuous * categorical interactions are set to \code{mean(X) * 1/N}
\item Dummy categorical * categorical interactions are set to \code{1/N * 1/M}
}

In comparison to \code{emmeans} this approach is equivalent to:

\if{html}{\out{<div class="sourceCode">}}\preformatted{emmeans::emmeans(model, specs = "<treatment>", weights = "equal")
}\if{html}{\out{</div>}}
}

\subsection{Proportional}{

For \code{weights = "proportional_em"} the lsmeans are obtained as per \code{weights = "equal"}
except instead of weighting each observation equally they are weighted by the proportion
in which the given combination of categorical values occurred in the data.
In comparison to \code{emmeans} this approach is equivalent to:

\if{html}{\out{<div class="sourceCode">}}\preformatted{emmeans::emmeans(model, specs = "<treatment>", weights = "proportional")
}\if{html}{\out{</div>}}

Note that this is not to be confused with \code{weights = "proportional"} which is an alias
for \code{weights = "counterfactual"}.
}
}

\examples{
\dontrun{
# 3-group analysis
data$treatment <- factor(data$treatment, levels = c("Control", "Low", "High"))
vars <- set_vars(
    outcome = "response",
    group = "treatment",
    visit = "visit",
    covariates = c("age", "sex")
)
result <- ancova_m_groups(data, vars)

# With group interactions
vars_int <- set_vars(
    outcome = "response",
    group = "treatment",
    visit = "visit",
    covariates = c("age", "sex", "treatment*age")
)
result_int <- ancova_m_groups(data, vars_int)
}

}
\seealso{
\code{\link[=ancova]{ancova()}} for two-group analysis

\code{\link[=analyse]{analyse()}}

\code{\link[stats:lm]{stats::lm()}}

\code{\link[=set_vars]{set_vars()}}
}

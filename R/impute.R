



#' Create Imputed Datasets
#'
#' `impute` is used to create imputed datasets based upon the data and options specified in the
#' call to [draws()]. One imputed dataset is created per `draw` "sample".
#'
#' @param draws A draws object created by [draws()].
#'
#' @param references a named vector. Identifies the references to be used when generating the imputed
#' values. Should be of the form `c("Group" = "Reference", "Group" = "Reference")`.
#'
#' @param update_ice an optional dataframe. Updates the imputation method that was originally set via
#' the `data_ice` option in `draws`. See the details section for more information.
#'
#' @param strategies a named list of functions. Defines the imputation functions to be used. The names
#' of of the list should mirror the values specified in `method` column of `data_ice`.
#' Default = `getStrategies()`. See [getStrategies()] for more details.
#'
#' @details
#'
#' `impute` works by taking the model parameter estimates generated by [draws()] and using them to calculate
#' the conditional distribution for the outcome for each subject separately. These distributions are then augmented
#' based upon the date of the ICE, the selected strategy and the chosen reference group. Each imputed dataset is
#' they constructed based upon the method as specified in the call to [draws()] with 1 dataset being generated per
#' set of parameter estimates provided by [draws()].
#'
#' - Bayes & Approximate Bayes: Each imputed dataset consists of 1 row per subject & visit from the original
#' dataset with missing values imputed by taking a single random sample from the augmented outcome distribution.
#'
#' - Conditional Mean: Each imputed dataset consists of 1 row per subject & visit from the bootstrapped or jackknife
#' dataset that was used to generate the corresponding parameter estimates in [draws()].
#' Missing values are imputed by using the mean of the augmented outcome distribution.
#'
#' For conditional mean and approximate Bayes the first imputed dataset will be the original dataset imputed
#' using the MLE parameter estimates of the
#' mmrm model fitted to the original dataset. See TODO (reference paper for methods) for full details.
#'
#'
#' `update_ice` can be used to update the imputation method that was originally set via
#' the `data_ice` option in `draws`.
#' The `update_ice` dataframe must contain two columns, one for the subject ID and another for the imputation method,
#' whose names are the same as
#' those defined in `vars` argument as specified in the call to `draws`.
#' You can only update the imputation method, that is to say that specifying
#' a visit column has no effect here. If you wish to change the ICE visit date you will need to re-run `draws`.
#' A key limitation is that you can only switch between a MAR and a non-MAR method (or vice versa)
#' if that subject has no non-missing post ICE data.
#' As an example, if a subject had their ICE on "Visit 2" but still had values in the dataset for
#' "Visit 3" then the function will throw and error if you try to switch them from MAR to a non-MAR method or
#' from a non-MAR method to MAR.
#'
#' @examples
#' \dontrun{
#'
#' impute(
#'     draws = drawobj,
#'     references = c("Trt" = "Placebo", "Placebo" = "Placebo")
#' )
#'
#' new_ice <- data.frame(
#'   subjid = c("Pt1", "Pt2"),
#'   method = c("MAR", "JR")
#' )
#'
#' impute(
#'     draws = drawobj,
#'     references = c("Trt" = "Placebo", "Placebo" = "Placebo"),
#'     update_ice = new_ice
#' )
#' }
#'
#' @export
impute <- function(draws, references, update_ice = NULL, strategies = getStrategies()) {
    UseMethod("impute")
}



#' @rdname impute
#' @export
impute.random <- function(draws, references, update_ice = NULL, strategies = getStrategies()) {
    result <- impute_internal(
        draws = draws,
        update_ice = update_ice,
        references = references,
        strategies = strategies,
        condmean = FALSE
    )
    return(as_class(result, "imputation"))
}




#' @rdname impute
#' @export
impute.condmean <- function(draws, references, update_ice = NULL, strategies = getStrategies()) {
    result <- impute_internal(
        draws = draws,
        update_ice = update_ice,
        references = references,
        strategies = strategies,
        condmean = TRUE
    )
    return(as_class(result, "imputation"))
}


#'  Create Imputed Datasets
#'
#' This is the work horse function that implements most of the functionality of impute. See the user level
#' function [impute()] for further details.
#'
#' @param draws A draws object created by [draws()].
#'
#' @param references a named vector. Identifies the references to be used when generating the imputed
#' values. Should be of the form `c("Group" = "Reference", "Group" = "Reference")`.
#'
#' @param update_ice an optional dataframe. Updates the imputation method that was originally set via
#' the `data_ice` option in `draws`. See the details section for more information.
#'
#' @param strategies a named list of functions. Defines the imputation functions to be used. The names
#' of of the list should mirror the values specified in `method` column of `data_ice`.
#' Default = `getStrategies()`. See [getStrategies()] for more details.
#'
#' @param condmean logical. If TRUE will impute using the conditional mean values, if values
#' will impute by taking a random draw from the multivariate normal distribution.
impute_internal <- function(draws, references, update_ice, strategies, condmean) {

    data <- draws$data$clone(deep = TRUE)

    validate_references(references, data$data[[data$vars$group]])
    validate_strategies(strategies, data$strategies)

    if (!is.null(update_ice)) {
        data$update_strategies(update_ice)
    }

    validate(draws$samples)
    samples_grouped <- transpose_samples(draws$samples)

    imputes <- mapply(
        impute_data_individual,
        names(samples_grouped$index),
        samples_grouped$index,
        MoreArgs = list(
            beta = samples_grouped$beta,
            sigma = samples_grouped$sigma,
            data = data,
            references = references,
            strategies = strategies,
            condmean = condmean
        ),
        SIMPLIFY = FALSE
    )

    x <- list(
        imputations = untranspose_imputations(imputes, lapply(draws$samples, function(x) x$ids)),
        data = data,
        method = draws$method,
        references = references
    )
    return(x)
}



#' TODO
#'
#' @param imputations TODO
#' @param samples_ids TODO
untranspose_imputations <- function(imputations, sample_ids) {

    imp_names <- vapply(imputations, function(x) x$id, character(1))
    assert_that(length(imp_names) == length(imputations))
    names(imputations) <- imp_names
    sids <- sample_ids
    uids <- unique(unlist(sids))

    assert_that(
        all(uids %in% imp_names),
        msg = "sample_ids contains an id not available in imputations"
    )


    index <- list()
    for (i in uids) index[[i]] <- 1
    hold <- list()
    for (i in seq_along(sids)) {
        hold[[i]] <- list()
        for (j in seq_along(sids[[i]])) {
            id <- sids[[i]][[j]]
            ind <- index[[id]]
            values <- imputations[[id]]$values[[ind]]
            hold[[i]][[j]] <- as_imputation_single(id = id, values = values)
            index[[id]] <- index[[id]] + 1
        }
        hold[[i]] <- as_imputation_list(hold[[i]])
    }

    vapply(hold, validate, logical(1))

    number_used <- sum(vapply(hold, function(x) length(x), numeric(1)))
    number_avail_1 <- length(unlist(sids))
    number_avail_2 <- sum(vapply(imputations, function(x) length(x$values), numeric(1)))
    assert_that(
        number_used == number_avail_1,
        number_avail_2 == number_avail_1,
        msg = "Not all imputations have been used"
    )

    return(hold)
}





#' Transpose Samples
#'
#' Transposes samples generated by [draws()] so that they are grouped
#' by `subjid` instead of by sample number.
#'
#' @param samples A list of samples generated by [draws()]
transpose_samples <- function(samples) {

    beta <- list()
    sigma <- list()

    grp_names <- names(samples[[1]]$sigma)
    for (grp in grp_names) {
        sigma[[grp]] <-  vector(mode = "list", length = length(samples))
    }

    for (i in seq_along(samples)) {
        sample <- samples[[i]]
        beta[[i]] <- sample$beta
        for (grp in grp_names) sigma[[grp]][[i]] <-  sample$sigma[[grp]]
    }

    index <- invert_indexes(lapply(samples, function(x) x$ids))

    x <- list(
        beta = beta,
        sigma = sigma,
        index = index
    )
    return(x)
}




#' Invert and derive indexes
#'
#' Takes a list of elements and creates a new list
#' containing 1 entry per unique element value containing
#' the indexes of which original elements it occurred in.
#'
#' @details
#' This functions purpose is best illustrated by an example:
#'
#' input:
#'
#' ```
#' list( c("A", "B", "C"), c("A", "A", "B"))}
#' ```
#' becomes:
#'
#' ```
#' list( "A" = c(1,2,2), "B" = c(1,2), "C" = 1 )
#' ```
#'
#' @param x list of elements to invert and calculate index from (see details)
invert_indexes <- function(x) {
    lens <- vapply(x, function(x) length(x), numeric(1))
    grp <- rep(seq_along(x), lens)
    vals <- unlist(x, use.names = FALSE)
    uvals <- unique(vals)
    index <- split(grp, vals)[uvals]
    return(index)
}


#' Impute data for a single subject
#'
#' This function performs the imputation for a single subject at a time implementing the process as detailed
#' in [impute()].
#'
#' Note that this function performs all of the required imputations for a subject at the same time. I.e.
#' if a subject is used in samples  1,3,5,9 then these are all performed at once. The function supports patients
#' belonging to the same sample multiple times i.e.  1,1,2,3,5,5
#'
#' @param id Character string identifying the subject
#'
#' @param index The sample indexes which the subject belongs to i.e `c(1,1,1,2,2,4)`
#'
#' @param beta A list of beta coeficients for each sample, i.e. `beta[[1]]` is the set of beta coeficients
#' for the first sample
#'
#' @param sigma A list of the sigma coeficients for each sample split by group i.e. `sigma[[1]][["A"]]`
#' would give the sigma coeficients for group A for the first sample
#'
#' @param data A longdata object created by [longDataConstructor()]
#'
#' @param references a named vector. Identifies the references to be used when generating the imputed
#' values. Should be of the form `c("Group" = "Reference", "Group" = "Reference")`.

#' @param strategies a named list of functions. Defines the imputation functions to be used. The names
#' of of the list should mirror the values specified in `method` column of `data_ice`.
#' Default = `getStrategies()`. See [getStrategies()] for more details.
#'
#' @param condmean logical. If TRUE will impute using the conditional mean values, if values
#' will impute by taking a random draw from the multivariate normal distribution.
impute_data_individual <- function(
    id,
    index,
    beta,
    sigma,
    data,
    references,
    strategies,
    condmean
) {

    # Define default return value if nothing needs to be imputed
    result <- list(
        id = id,
        values = replicate(n = length(index), numeric(0))
    )

    id_data <- data$extract_by_id(id)

    if (sum(id_data$is_missing) == 0) return(result)

    vars <- data$vars
    group_pt <- as.character(id_data$group)
    group_ref <- as.character(references[[group_pt]])


    dat_pt <- id_data$data
    dat_pt[, vars$outcome] <- 1  # Dummy outcome value to stop rows being dropped by model.matrix
    dat_ref <- dat_pt
    dat_ref[, vars$group] <- factor(group_ref, levels = levels(id_data$group))

    dat_pt_mod <- as_model_df(dat_pt, as_simple_formula(vars))
    dat_ref_mod <- as_model_df(dat_ref, as_simple_formula(vars))

    parameters_group <- get_visit_distribution_parameters(
        dat = dat_pt_mod[-1],  # -1 as first col from as_model_df is the outcome variable
        beta = beta[index],
        sigma = sigma[[group_pt]][index]
    )

    parameters_reference <- get_visit_distribution_parameters(
        dat = dat_ref_mod[-1], # -1 as first col from as_model_df is the outcome variable
        beta = beta[index],
        sigma = sigma[[group_ref]][index]
    )

    pars <- mapply(
        strategies[[id_data$strategy]],
        parameters_group,
        parameters_reference,
        MoreArgs = list(index_mar = id_data$is_mar),
        SIMPLIFY = FALSE
    )

    conditional_parameters <- lapply(
        pars,
        get_conditional_parameters,
        values = id_data$outcome
    )

    if (condmean) {
        imputed_outcome <- lapply(conditional_parameters, function(x) as.vector(x$mu))
    } else {
        imputed_outcome <- lapply(conditional_parameters, impute_outcome)
    }

    result$values <- imputed_outcome
    return(result)
}


#' Derive visit distribution parameters
#'
#' Takes patient level data and beta coefficients and expands them
#' to get an patient specific estimate for the visit distribution parameters
#' `mu` and `sigma`. Returns the values in a specific format
#' which is expected by downstream functions in the imputation process
#' (namely  `list(list(mu = ..., sigma = ...), list(mu = ..., sigma = ...))`)
#'
#' @param dat Patient level dataset, must be 1 row per visit. Column order must
#' be in the same order as beta. The number of columns must match the length of beta
#' @param beta List of model beta coefficients 1 for each sample i.e. `list( c(1,2,3) , c(4,5,6), c(7,8,9))`
#' all values of beta must be the same length and must be the same length and order as `dat`
#' @param sigma List of sigma. Must have the same number of entries as `beta`
get_visit_distribution_parameters <- function(dat, beta, sigma) {

    assert_that(
        length(unique(vapply(beta, length, numeric(1)))) == 1,
        msg = "All elements of beta must be the same length"
    )

    beta_mat <- matrix(
        unlist(beta, use.names = FALSE),
        nrow = length(beta[[1]]),
        ncol = length(beta),
        byrow = FALSE
    )
    mu <- as.matrix(dat) %*% beta_mat
    parameters <- list()
    for (i in seq_along(beta)) {
        parameters[[i]] <- list(
            mu = mu[, i],
            sigma = sigma[[i]]
        )
    }
    return(parameters)
}


#' Sample outcome value
#'
#' Draws a random sample from a multivariate normal distribution
#'
#' @param conditional_parameters a list with elements `mu` and `sigma` which
#' contain the mean vector and covariance matrix to sample from
#' @importFrom stats rnorm
impute_outcome <- function(conditional_parameters) {

    assert_that(
        all(!is.na(conditional_parameters$mu)),
        all(!is.na(conditional_parameters$sigma)),
        msg = "Sigma or Mu contain missing values"
    )

    result <- sample_mvnorm(
        conditional_parameters$mu,
        conditional_parameters$sigma
    )

    return(as.vector(result))
}




#' Derive conditional multivariate normal parameters
#'
#' Takes parameters for a multivariate normal distribution + known values
#' to calculate the conditional distribution for the unknown values
#'
#' @param pars a list with values "mu" and "sigma" defining the mean vector and
#' covariance matrix respectively
#' @param values a vector of known values to condition on, must be same length as pars$mu.
#' Missing values must be represented by an NA
#'
#' @return A list with the conditional distribution parameters
#'
#' - mu - The conditional mean vector
#' - sigma - The conditional covariance matrix
#'
get_conditional_parameters <- function(pars, values) {
    q <- is.na(values)

    if (sum(q) == length(values)) return(pars)
    if (sum(q) == 0) return(list(mu = numeric(0), sigma = numeric(0)))

    a <- values[!q]

    mu1 <- matrix(nrow = sum(q), pars$mu[q])
    mu2 <- matrix(nrow = sum(!q), pars$mu[!q])

    sig11 <- pars$sigma[q, q, drop = FALSE]
    sig12 <- pars$sigma[q, !q, drop = FALSE]
    sig21 <- pars$sigma[!q, q, drop = FALSE]
    sig22 <- pars$sigma[!q, !q, drop = FALSE]

    sig22_inv_12 <-  sig12 %*% solve(sig22)

    x <- list(
        mu = mu1 + sig22_inv_12 %*% (a - mu2),
        sigma = sig11 - sig22_inv_12 %*% sig21
    )
    return(x)
}


#' Validate user supplied references
#'
#' Checks to ensure that the user specified references are
#' expect values (i.e. those found within the source data)
#'
#' @param references named character vector
#' @param control factor variable (should be the `group` variable from the source dataset)
#'
#' @return
#' Will error if there is an issue otherwise will return `TRUE`
validate_references <- function(references, control) {

    ref_names <- names(references)

    assert_that(
        is.character(references),
        !is.null(ref_names),
        all(!is.na(references)),
        msg = "`references` should be a non-missing named character vector"
    )

    assert_that(
        all(ref_names != ""),
        msg = "All values of `references` must be named"
    )

    assert_that(
        length(unique(ref_names)) == length(ref_names),
        msg = "`references` must have unique names"
    )

    assert_that(
        is.factor(control),
        msg = "`control` should be a factor vector"
    )

    unique_refs <- unique(c(references, ref_names))
    valid_refs <- unique(as.character(control))

    assert_that(
        all(unique_refs %in% valid_refs),
        msg = paste0(
            "`references` contains values that are not present in the",
            "`group` variable of your source dataset"
        )
    )
    return(invisible(TRUE))
}


#' Validate user specified strategies
#'
#' Compares the user provided strategies to those that are
#' required (the reference). Will error if not all values
#' of reference have been defined
#'
#' @param strategies named list of strategies
#' @param reference list or character vector of strategies that need to be defined
#'
#' @return
#' Will error if there is an issue otherwise will return `TRUE`
validate_strategies <- function(strategies, reference) {

    strat_names <- names(strategies)

    assert_that(
        is.list(strategies),
        !is.null(strat_names),
        all(vapply(strategies, is.function, logical(1))),
        msg = "`strategies` must be a named list of functions"
    )

    assert_that(
        length(strat_names) == length(unique(strat_names)),
        msg = "`strategies` must be uniquely named"
    )

    unique_references <- unique(unlist(reference, use.names = FALSE))

    for (ref in unique_references) {
        assert_that(
            ref %in% strat_names,
            msg = sprintf("Required strategy `%s` has not been defined", ref)
        )
    }
    return(invisible(TRUE))
}



#' Create a valid imputation_single object
#'
#' @param id a character string specifying the subject id
#' @param values a numeric vector indicating the imputed values
as_imputation_single <- function(id, values) {
    x <- list(id = id, values = values)
    class(x) <- c("imputation_single", "list")
    validate(x)
    return(x)
}

#' @export
validate.imputation_single <- function(x, ...) {
    assert_that(
        length(x$id) == 1,
        is.character(x$id),
        is.numeric(x$values) | is.null(x$values)
    )
    return(TRUE)
}


#' Create a valid imputation list object
#'
#' @param ... a list of imputation_singles
as_imputation_list <- function(...) {
    x <- list(...)
    if (length(x) == 1 & class(x[[1]])[[1]] != "imputation_single") {
        x <- x[[1]]
    }
    class(x) <- c("imputation_list", "list")
    validate(x)
    return(x)
}



#' @export
validate.imputation_list <- function(x, ...) {
    assert_that(
        is.null(names(x)),
        all(vapply(x, function(x) class(x)[[1]] == "imputation_single", logical(1)))
    )
    vapply(x, validate, logical(1))
    return(TRUE)
}



#' Print Imputation Object
#'
#' @param x (`imputation`)\cr input
#' @param ... not used
#' @export
print.imputation <- function(x, ...) {

    ### Reference strings i.e.  A -> B
    ref_from <- names(x$references)
    ref_to <- x$references
    width <- max(nchar(ref_from))
    sstring <- paste0("%-", width, "s -> %s")
    ref_strings <- sprintf(sstring, ref_from, ref_to)

    ### % of missing data strings
    is_miss <- matrix(unlist(x$data$is_missing), ncol = length(x$data$visits), byrow = TRUE)
    is_miss_perc <- round((apply(is_miss, 2, sum) / nrow(is_miss)) * 100)
    width <- max(nchar(x$data$visits))
    sstring <- paste0("%-", width, "s: %3s%%")
    miss_strings <- sprintf(sstring, x$data$visits, is_miss_perc)

    string <- c(
        "",
        "Imputation Object",
        "-----------------",
        sprintf("Number of Imputed Datasets: %s", length(x$imputations)),
        "Fraction of Missing Data (Original Dataset):",
        sprintf("    %s", miss_strings),
        "References:",
        sprintf("    %s", ref_strings),
        ""
    )

    cat(string, sep = "\n")
    return(invisible(x))
}

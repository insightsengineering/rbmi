



#' Analyse Multiple Imputed Datasets
#'
#' @description
#' This function takes multiple imputed datasets (as generated by
#' the [impute()] function) and runs an analysis function on
#' each of them.
#'
#' @details
#' This function works by performing the following steps:
#'
#' 1. Extract a dataset from the `imputations` object.
#' 2. Apply any delta adjustments as specified by the `delta` argument.
#' 3. Run the analysis function `fun` on the dataset.
#' 4. Repeat steps 1-3 across all of the datasets inside the `imputations`
#' object.
#' 5. Collect and return all of the analysis results.
#'
#' The analysis function `fun` must take a `data.frame` as its first
#' argument. All other options to [analyse()] are passed onto `fun`
#' via `...`.
#' `fun` must return a named list with each element itself being a
#' list containing a single
#' numeric element called `est` (or additionally `se` and `df` if
#' you had originally specified [method_bayes()] or [method_approxbayes()])
#' i.e.:
#' ```
#' myfun <- function(dat, ...) {
#'     mod_1 <- lm(data = dat, outcome ~ group)
#'     mod_2 <- lm(data = dat, outcome ~ group + covar)
#'     x <- list(
#'         analysis_result(
#'             name = trt_1,
#'             est = coef(mod_1)[[group]],
#'             se = sqrt(vcov(mod_1)[group, group]),
#'             df = df.residual(mod_1)
#'         ),
#'         analysis_result(
#'             name = trt_2,
#'             est = coef(mod_2)[[group]],
#'             se = sqrt(vcov(mod_2)[group, group]),
#'             df = df.residual(mod_2)
#'         )
#'      )
#'      return(x)
#'  }
#' ```
#'
#' Please note that the `vars$subjid` column (as defined in the original call to
#' [draws()]) will be scrambled in the data.frames that are provided to `fun`.
#' This is to say they will not contain the original subject values and as such
#' any hard coding of subject ids is strictly to be avoided.
#'
#' By default `fun` is the [ancova()] function.
#' Please note that this function
#' requires that a `vars` object, as created by [set_vars()], is provided via
#' the `vars` argument e.g. `analyse(imputeObj, vars = set_vars(...))`. Please
#' see the documentation for [ancova()] for full details.
#' Please also note that the theoretical justification for the conditional mean imputation
#' method (`method = method_condmean()` in [draws()]) relies on the fact that ANCOVA is
#' a linear transformation of the outcomes.
#' Thus care is required when applying alternative analysis functions in this setting.
#'
#' The `delta` argument can be used to specify offsets to be applied
#' to the outcome variable in the imputed datasets prior to the analysis.
#' This is typically used for sensitivity or tipping point analyses. The
#' delta dataset must contain columns `vars$subjid`, `vars$visit` (as specified
#' in the original call to [draws()]) and `delta`. Essentially this `data.frame`
#' is merged onto the imputed dataset by `vars$subjid` and `vars$visit` and then
#' the outcome variable is modified by:
#'
#' ```
#' imputed_data[[vars$outcome]] <- imputed_data[[vars$outcome]] + imputed_data[["delta"]]
#' ```
#'
#' Please note that in order to provide maximum flexibility, the `delta` argument
#' can be used to modify any/all outcome values including those that were not
#' imputed. Care must be taken when defining offsets. It is recommend that you
#' use the helper function [delta_template()] to define the delta datasets as
#' this provides utility variables such as `is_missing` which can be used to identify
#' exactly which visits have been imputed.
#'
#' @seealso [extract_imputed_dfs()] for manually extracting imputed
#' datasets.
#' @seealso [delta_template()] for creating delta data.frames.
#' @seealso [ancova()] for the default analysis function.
#'
#' @param imputations An `imputations` object as created by [impute()].
#' @param fun An analysis function to be applied to each imputed dataset. See details.
#' @param delta A `data.frame` containing the delta transformation to be applied to the imputed, or a `function` to apply the delta transformation
#' datasets prior to running `fun`. See details.
#' @param ... Additional arguments passed onto `fun`.
#' @examples
#' \dontrun{
#' vars <- set_vars(
#'     subjid = "subjid",
#'     visit = "visit",
#'     outcome = "outcome",
#'     group = "group",
#'     covariates = c("sex", "age", "sex*age")
#' )
#'
#' analyse(
#'     imputations = imputeObj,
#'     vars = vars
#' )
#'
#' deltadf <- data.frame(
#'     subjid = c("Pt1", "Pt1", "Pt2"),
#'     visit = c("Visit_1", "Visit_2", "Visit_2"),
#'     delta = c( 5, 9, -10)
#' )
#'
#' analyse(
#'     imputations = imputeObj,
#'     delta = deltadf,
#'     vars = vars
#' )
#'
#' delta_fun <- function(df) mutate(df, out + 1)
#' analyse(
#'     imputations = imputeObj,
#'     delta = delta_fun,
#'     vars = vars
#' )
#' }
#' @export
analyse <- function(imputations, fun = ancova, delta = NULL, ...) {

    validate(imputations)

    assert_that(
        is.function(fun),
        msg = "`fun` must be a function"
    )

    assert_that(
        is.null(delta) | is.data.frame(delta) | is.function(delta),
        msg = "`delta` must be NULL or a data.frame or a function"
    )

    vars <- imputations$data$vars

    devnull <- lapply(imputations$imputations, function(x) validate(x))

    if (is.data.frame(delta)) {
        expected_vars <- c(
            vars$subjid,
            vars$visit,
            "delta"
        )
        assert_that(
            all(expected_vars %in% names(delta)),
            msg = sprintf(
                "The following variables must exist witin `delta`: `%s`",
                paste0(expected_vars, collapse = "`, `")
            )
        )
    }

    results <- lapply(
        imputations$imputations,
        function(x, ...) {
            dat2 <- extract_imputed_df(x, imputations$data, delta)
            fun(dat2, ...)
        },
        ...
    )

    fun_name <- deparse(substitute(fun))
    if (length(fun_name) > 1) {
        fun_name <- "<Anonymous Function>"
    } else if (is.null(fun_name)) {
        fun_name <- "<NULL>"
    }

    ret <- as_analysis(
        results = results,
        fun_name = fun_name,
        delta = delta,
        fun = fun,
        method = imputations$method
    )
    validate(ret)
    return(ret)
}



#' Extract imputed datasets
#'
#' @description
#' Extracts the imputed datasets contained within an `imputations` object generated
#' by [impute()].
#'
#' @param imputations An `imputations` object as created by [impute()].
#' @param index The indexes of the imputed datasets to return. By default,
#' all datasets within the `imputations` object will be returned.
#' @param delta A `data.frame` containing the delta transformation to be
#' applied to the imputed dataset. See [analyse()] for details on the
#' format and specification of this `data.frame`.
#' @param idmap Logical. The subject IDs in the imputed `data.frame`'s are
#' replaced with new IDs to ensure they are unique. Setting this argument to
#' `TRUE` attaches an attribute, called `idmap`, to the returned `data.frame`'s
#' that will provide a map from the new subject IDs to the old subject IDs.
#'
#' @examples
#' \dontrun{
#' extract_imputed_dfs(imputeObj)
#' extract_imputed_dfs(imputeObj, c(1:3))
#' }
#' @returns
#' A list of data.frames equal in length to the `index` argument.
#'
#' @seealso [delta_template()] for creating delta data.frames.
#' @seealso [analyse()].
#' @export
extract_imputed_dfs <- function(
    imputations,
    index = seq_along(imputations$imputations),
    delta = NULL,
    idmap = FALSE
) {
    x <- imputations$imputations[index]
    lapply(
        x,
        function(x) extract_imputed_df(x, imputations$data, delta, idmap)
    )
}


#' Extract imputed dataset
#'
#' @description
#' Takes an imputation object as generated by [imputation_df()] and uses
#' this to extract a completed dataset from a `longdata` object as created
#' by [longDataConstructor()]. Also applies a delta transformation
#' if a `data.frame` is provided to the `delta` argument. See [analyse()] for
#' details on the structure of this `data.frame`.
#'
#' Subject IDs in the returned `data.frame` are scrambled i.e. are not the original
#' values.
#'
#' @param imputation An imputation object as generated by [imputation_df()].
#' @param ld A `longdata` object as generated by [longDataConstructor()].
#' @param delta Either `NULL` or a `data.frame` or `function`. Is used to offset outcome values in the imputed dataset.
#' @param idmap Logical. If `TRUE` an attribute called "idmap" is attached to
#' the return object which contains a `list` that maps the old subject ids
#' the new subject ids.
#' @param oldvar character vector for dummy variable name to avoid collision. It should be same as the one used in [apply_delta()].
#' @returns A `data.frame`.
extract_imputed_df <- function(imputation, ld, delta = NULL, idmap = FALSE,
                               oldvar = "old_subject_variable_zkfed1fgkadwni6g4oajd2aw") {

    vars <- ld$vars
    dat <- ld$get_data(imputation, idmap = TRUE)
    id_map <- attr(dat, "idmap")

    if (!is.null(delta)) {
        # We are injecting a variable into the dataset so are using a obscured variable
        # name to remove the chance of a clash
        dat[[oldvar]] <- id_map[dat[[vars$subjid]]]
        dat2 <- apply_delta(
            dat,
            vars$subjid,
            delta = delta,
            group = c(oldvar, vars$visit),
            outcome = vars$outcome,
            oldvar = oldvar
        )
        dat2[[oldvar]] <- NULL
    } else {
        dat2 <- dat
    }

    dat2 <- as_dataframe(dat2)

    if (idmap) {
        attr(dat2, "idmap") <- id_map
    } else {
        attr(dat2, "idmap") <- NULL
    }

    return(dat2)
}



#' Construct an `analysis` object
#'
#' @description
#' Creates an analysis object ensuring that all components are
#' correctly defined.
#'
#' @param results A list of lists contain the analysis results for each imputation
#' See [analyse()] for details on what this object should look like.
#' @param method The method object as specified in [draws()].
#' @param delta The delta dataset or function used. See [analyse()] for details on how this
#' should be specified.
#' @param fun The analysis function that was used.
#' @param fun_name The character name of the analysis function (used for printing)
#' purposes.
as_analysis <- function(results, method, delta = NULL, fun = NULL, fun_name = NULL) {

    next_class <- switch(class(method)[[2]],
        bayes = "rubin",
        approxbayes = "rubin",
        condmean = ifelse(
            method$type == "jackknife",
            "jackknife",
            "bootstrap"
        ),
        bmlmi = "bmlmi"
    )

    assert_that(
        is.list(results),
        length(next_class) == 1,
        is.character(next_class),
        next_class %in% c("jackknife", "bootstrap", "rubin", "bmlmi")
    )

    x <- list(
        results = as_class(results, c(next_class, "list")),
        delta = delta,
        fun = fun,
        fun_name = fun_name,
        method = method
    )
    class(x) <- c("analysis", "list")
    validate(x)
    return(x)
}



#' Print `analysis` object
#'
#' @param x An `analysis` object generated by [analyse()].
#' @param ... Not used.
#' @importFrom utils capture.output
#' @export
print.analysis <- function(x, ...) {

    n_samp <- length(x$results)
    n_samp_string <- ife(
        has_class(x$results, "bootstrap") | has_class(x$results, "jackknife"),
        sprintf("1 + %s", n_samp - 1),
        n_samp
    )

    string <- c(
        "",
        "Analysis Object",
        "---------------",
        sprintf("Number of Results: %s", n_samp_string),
        sprintf("Analysis Function: %s", x$fun_name),
        sprintf("Delta Applied: %s", !is.null(x$delta)),
        "Analysis Estimates:",
        as_ascii_table(analysis_info(x$results[[1]])),
        ""
    )

    cat(string, sep = "\n")
    return(invisible(x))
}



#' Validate `analysis` objects
#'
#' Validates the return object of the [analyse()] function.
#'
#' @param x An `analysis` results object (of class `"jackknife"`, `"bootstrap"`, `"rubin"`).
#' @param ... Not used.
#' @export
validate.analysis <- function(x, ...) {

    next_class <- class(x$results)[[1]]

    assert_that(
        next_class %in% c("jackknife", "bootstrap", "rubin", "bmlmi"),
        msg = "`results` must be of class 'jackknife', 'bootstrap', 'rubin' or 'bmlmi'"
    )

    if (next_class %in% c("bootstrap", "rubin")) {
        nsamp <- ife(
            next_class %in% c("bootstrap"),
            x$method$n_sample + 1,
            x$method$n_sample
        )
        assert_that(
            length(x$results) == nsamp
        )
    }

    assert_that(
        is.list(x$results),
        is.null(x$delta) | is.data.frame(x$delta) | is.function(x$delta),
        is.null(x$fun) | is.function(x$fun),
        is.null(x$fun_name) | is.character(x$fun_name)
    )

    validate(x$results)
}


#' @export
validate.jackknife <- function(x, ...) {
    validate_analyse_pars(x, get_pool_components("jackknife"))
}


#' @export
validate.bootstrap <- function(x, ...) {
    validate_analyse_pars(x, get_pool_components("bootstrap"))
}

#' @export
validate.rubin <- function(x, ...) {
    validate_analyse_pars(x, get_pool_components("rubin"))
}

#' @export
validate.bmlmi <- function(x, ...) {
    validate_analyse_pars(x, get_pool_components("bmlmi"))
}


#' Validate analysis results
#'
#' Validates analysis results generated by [analyse()].
#'
#'
#' @param results A list of results generated by the analysis `fun`
#' used in [analyse()].
#' @param pars A list of expected parameters in each of the analysis.
#' lists i.e. `c("est", "se", "df")`.
#'
#' @export
validate_analyse_pars <- function(results, pars) {

    assert_that(
        length(results) != 0,
        is.list(results),
        all(vapply(results, is.list, logical(1))),
        msg = "Analysis results must be a list of lists"
    )

    assert_that(
        length(results[[1]]) != 0,
        all(vapply(results, function(Xs)
            all(vapply(Xs, function(X) is.analysis_result(X), logical(1))), logical(1))),
        msg = "Individual analysis result must be type of analysis_result"
    )

    compose <- function(f, g) function(...) f(g(...))

    process_2nd_last_level <- function(process) function (nestlst) back_apply_at(nestlst, process, 2)
    get_names <- process_2nd_last_level(function(x) x [['name']])
    dedup <- process_2nd_last_level(unique)

    get_unique_names <- compose(dedup, get_names)

    results_names <- get_unique_names(results)
    results_names_flat <- unlist(results_names, use.names = FALSE)
    results_names_count <- table(results_names_flat)

    assert_that(
        all(results_names_count == length(results)),
        msg = "Each individual analysis result must contain identically named elements"
    )

    results_unnested <- unlist(results, recursive = FALSE, use.names = FALSE)

    devnull <- lapply(
        results_unnested,
        function(x) {
            assert_that(
                is.list(x),
                all(pars %in% names(x)),
                msg = sprintf(
                    "Each individual analysis result element must be a list with elements `%s`",
                    paste0(pars, collapse = "`, `")
                )
            )
        }
    )

    for (par in pars) {
        if (!par %in% c("df", "se")) {
            assert_that(
                all(!is.na(vapply(results_unnested, function(x) x[[par]], numeric(1)))),
                msg = sprintf("Parameter `%s` contains missing values", par)
            )
        } else {
            assert_that(
                all(!is.na(vapply(results_unnested, function(x) x[[par]], numeric(1)))) ||
                all(is.na(vapply(results_unnested, function(x) x[[par]], numeric(1)))) ,
                msg = sprintf("Parameter `%s` contains both missing and observed values", par)
            )
        }
    }

    return(invisible(TRUE))
}

#' Constructor of analysis result
#'
#' Construct an analysis result class object whose base type is a list
#'
#' @param name A character variable for the group name
#' @param est A double type numeric variable as the estimate
#' @param se A double type numeric variable as the standard error
#' @param df An integer type of numeric variable
#' @param meta A list type of variable as meta information
#' @details
#' - `se`, `df` and `meta` is optional
#' - `se` and `df` if given must be numeric values greater or equal to 0
#' @return An object of "analysis_result" class
#' @examples
#' \dontrun{
#' ana_res_obj <- analysis_result(name = 'trt', est = 1, se = 2, df = 3, meta = list(visit = 1))
#' }
#' @export
analysis_result <- function (name,
                             est,
                             se = NULL,
                             df = NULL,
                             meta = NULL) {

    # constraints
    is.numeric_or_NA <- make_chain(any, is.numeric, anyNA)
    is.numeric_or_NA_or_NULL <- make_chain(any, is.numeric_or_NA, is.null)
    is.list_or_NULL <- make_chain(any, is.list, is.null)

    # asssert type for required parameter (directly assert type)
    assert_type(name, is.character)
    assert_type(est, is.numeric)

    # assert type for optional parameter (always include NULL)
    assert_type(se, is.numeric_or_NA_or_NULL)
    assert_type(df, is.numeric_or_NA_or_NULL)
    assert_type(meta, is.list_or_NULL)

    # assert length for required parameter
    assert_anares_length(name, 1)
    assert_anares_length(est, 1)

    # assert properties of optional parameters
    if (!is.null(se) & !anyNA(se)) {
        assert_anares_length(se, 1)

        assert_that(
        se >= 0,
        msg = "SE must be greater or equal to 0"
    )
    }

    if (!is.null(df) & !anyNA(df)) {
        assert_anares_length(df, 1)

        assert_that(
            df >= 0,
            msg = "DF must be greater or equal to 0"
        )
    }

    value <- list(name = name,
                  est = est)

    # optional parameters
    if (!is.null(se)) {
        value[['se']] <- se
    }

    if (!is.null(df)) {
        value[['df']] <- df
    }

    if (!is.null(meta)) {
        value[['meta']] <- meta
    }

    structure(
        value,
        meta = meta,
        class = c("analysis_result", "list")
    )
}

#' Convert object to analysis result class
#'
#' @param x The object to be converted to analysis_result class
#' @param ... Optional keywords parameters for adding missing elements to the object
#' @return An "analysis_result" class object with optionally updated elements
#' @examples
#' \dontrun{
#' ana_res_obj <- as_analysis_result(list(est = 1, se = 2, df = 3), name = 'trt')
#' }
as_analysis_result <- function(x, ...) {
    new_pars <- list(...)

    # coercion with generic function
    x <- as.list(x)

    present <- ana_name_chker()('musthave_in_objnames')

    names_not_presented <- names(present(x))[!present(x)]

    # update list if required elements are not presented or if the provided name is an optional element of analysis_result object
    updated_x <- x
    for (name in names(new_pars)) {
        if (name %in% names_not_presented | name %in% ana_name_chker()('optional')) {
            updated_x[[name]] <- new_pars[[name]]
        }
    }

    # after updating check if all required elements are presented
    assert_that(all(present(updated_x)),
                msg = "Required parameters are not presented after updating")

    # order the list by names
    ordered_x <- order_list_by_name(updated_x, ana_name_chker()('all'))

    # set attributes: meta & class
    if ('meta' %in% names(ordered_x)) {
        attr(ordered_x, 'meta') <- ordered_x[['meta']]
    }

    as_class(ordered_x, c("analysis_result", "list"))
}

#' Name checker for analysis_result object
#'
#' A higher order function returns an analysis name checker which is again a higher order function takes character vector as
#' type of dispatch message and returns selected check function or properties.
#' This function takes no argument. The point is to delay the evaluation and evaluate only when it is needed, similar idea as shiny ractive
#' @examples
#' \dontrun{
#' anares_names_in_musthave <- ana_name_chker()('objnames_in_musthave')
#' musthave_in_anares_names <- ana_name_chker()('musthave_in_objnames')
#' musthave_names <- ana_name_chker()('musthave')
#' optional_names <- ana_name_chker()('optional')
#' all_names <- ana_name_chker()('all')
#' }
ana_name_chker <- function() namechecker('name', 'est', optional = c('se', 'df', 'meta'))

#' Check if an object is in class analysis_result
#'
#' @param x Object to be checked
#' @return Logical value TRUE/FALSE
#' @details
#' This function does not only check the class attribute of the object.
#' It also checks constraints of the names of the elements in the list
#' @export
#' @importFrom assertthat has_attr
is.analysis_result <- function(x) {

    all(
        has_attr(x, 'class'),
        is.object(x),
        'analysis_result' %in% attr(x, 'class'),
        typeof(x) == 'list',
        all(ana_name_chker()('objnames_in_musthave')(x)),
        all(ana_name_chker()('musthave_in_objnames')(x))
    )
}

#' Convert a list of analysis_result objects to data.frame
#'
#' @param analst A list of `analysis_result` objects. It should not be the complete result of analysis object but a subset of it such as `anaObj$results[[1]]`
#' @param name_of_group A `character` variable for the name of group variable in the result of analysis which is defined from `analysis_result`. Default: `'name'`
#' @param name_of_meta A `character` variable for the name of meta data in the result of analysis which is defined from `analysis_result`. Default: `'meta'`
#' @return A `data.frame` containing the information of the analysis result from the `analst`
#' @examples
#' \dontrun{
#' analysis_info(dat, name_of_group = 'name', name_of_meta = 'meta')
#' }
#' @importFrom assertthat has_attr
analysis_info <- function(analst, name_of_group = 'name', name_of_meta = 'meta') {

    pars_no_meta <- list()
    pars_with_meta <- list()
    meta <- list()
    var <- list()

    index <- function(i, body) {
        list(
            append(list(index=i), body)
            )
    }

    for (i in seq_along(analst)) {
        item <- analst[[i]]

        assert_that(is.analysis_result(item),
                    msg = "Object in `analst` is not in `analysis_result` class")

        if (has_attr(item, name_of_meta)){
            meta <- append(meta, index(i, item[[name_of_meta]]))
            var <- append(var, list(item[name_of_group]))
            pars_with_meta <- append(pars_with_meta, index(i, item[names(item) != name_of_meta]))
        } else {
            pars_no_meta <- append(pars_no_meta, index(i, item))
        }
    }

    base_left_join <- function(x, y, by) merge(x, y, by = by, all.x=TRUE)

    all_pars <- append(pars_with_meta, pars_no_meta)

    res_df <- base_bind_rows(all_pars)

    meta_df <- cbind(base_bind_rows(var), base_bind_rows(meta))

    info_df <- tryCatch(
        base_left_join(res_df, meta_df, by = c('index', name_of_group)),
        error=function(e) res_df
    )

    subset(info_df, select = -index)
}

#' Convert analysis results to a data.frame
#'
#' @param analst Results of analysis object (`anaObj$results`)
#' @param index logical variable indicating whether to add index column for imputation dataset. Default: `FALSE` - no index column will be added.
#' @return A data frame each row of which corresponds to a analysis result
analst2df <- function(analst, index = FALSE) {

    add_index <- function(dt, i) cbind(dt, 'dt_num' = i)

    binarize <- function(f, side = 'left') {
        laze <- function(x) function() x
        trivial <- function(x, y) list(left=x, right=y)[[side]]
        function(g = trivial) {
            function(x, y) {
                list(
                    left = laze(g(f(x), y)),
                    right = laze(g(x, f(y)))
                )[[side]]()
            }
        }
    }

    anainfo <- binarize(analysis_info)
    ana2df <- ife(index, anainfo(add_index), anainfo())

    base_bind_rows(mapply(ana2df, analst, seq_along(analst), SIMPLIFY = FALSE))
}

#' @rdname analyse
#' @export
as.data.frame.analysis <- function(x, ...) {
    analst2df(x$results, index = TRUE)
}

#' Extract analysis results from a list of analysis_results by matching names and values
#'
#' The function returns a list of all analysis results in the input list that match the values with names specified via keywords parameters of the function.
#' If no value matches the specified name in any sub list of analysis result or
#' the specified name does not existed, the function returns an empty list `list()`.
#' This function has general application for any type of nested list with named sublist that can be treated as analysis result.
#' For example, `extract_analysis_result(poolObj$pars, name = 'p1', visit = 1)` would extract the result from the parameters of the pool object with `name` as `'p1'` and `visit` as `1`.
#'
#' @param results A list of analysis results. It can be a list of `analysis_result` objects or more generally a nested list with named sublists which can be treated as analysis result such `poolObj$pars`
#' @param ... Keywords parameters with the name and value matching the element of the `analysis_result` objects inside the `results`
#' @return A list of matched analysis results
#' @export
#' @examples
#' \dontrun{
#' results <- list(
#'     analysis_result(
#'         name = 'trt',
#'         est = 1,
#'         se = 2,
#'         df = 3,
#'         meta = list(visit = 'vis1')
#'     ),
#'     analysis_result(
#'         name = 'trt2',
#'         est = 3,
#'         se = 4,
#'         df = 5,
#'         meta = list(visit = 'vis2')
#'     )
#' )
#'
#' extract_analysis_result(results, name = 'trt')
#' extract_analysis_result(results, est = 1)
#' extract_analysis_result(results, name = 'trt', meta = list(visit = 'vis1'))
#' extract_analysis_result(results, name = 'trt2')
#
#' }
extract_analysis_result <- function(results, ...){
    dots <- list(...)

    assert_keyword <- function(obj, msg) {
        assert_that(all(!is.null(names(obj)),
                        length(names(obj)) > 0,
                        !any(grepl("^$", names(obj)))),
                    msg = msg
                    )
    }

    assert_keyword(dots, "Invalid parameters. Only key-word parameters are valide. -- EXTRACT_ANALYSIS_RESULT")

    meta <- list()
    has_meta <- FALSE
    if (('meta' %in% names(dots)) & is.list(dots[['meta']])) {
        assert_keyword(dots[['meta']],
                       "Invalid parameters. When `meta` specified as a list, it must be a named list -- EXTRACT_ANALYSIS_RESULT")
        meta <- dots[['meta']]
        dots[['meta']] <- NULL
        has_meta <- TRUE
    }

    # decorator to make a high-order function returns TRUE/FALSE instead of logical(0) or other types of logical value
    TRUE_or_FALSE <- function(f) {
        function(...) {
            g <- f(...)
            function(...) isTRUE(g(...))
        }
    }

    # check if object's element with given name matches to specified value
    objname_match_value <- function(obj) {
        function(name, value) {
            if (is.null(value)) {
                is.null(obj[[name]])
            } else if (is.na(value)){
                is.na(obj[[name]])
            } else {
                obj[[name]] == value
            }
        }
    }

    # decorated version of objname_match_value
    is_objname_match_value <- TRUE_or_FALSE(objname_match_value)

    names_match_values <- function(obj, named_values=dots) {
        mapply(
            is_objname_match_value(obj),
            names(named_values),
            named_values,
            SIMPLIFY = TRUE, USE.NAMES = FALSE)
    } # When SIMPLIFY = TRUE, coercion can happen on logical(0) which generates WARNINGS. `is_objname_match_value` is decorated with `isTRUE` to be more robust

    extract_match <- function(obj, named_values=dots, constrain = identity) {
        Filter(
            function(item) all(names_match_values(constrain(item), named_values)),
            obj
        )
    }

    search_in_meta <- function(obj) obj[['meta']]

    extract_meta <- function(obj) extract_match(obj, named_values = meta, constrain = search_in_meta)

    tryCatch({
            matches_except_meta <- extract_match(results)

            if (has_meta) {
                extract_meta(matches_except_meta)
            } else {
                matches_except_meta
           }
        },
        warning = function(w) {
            message(w)
            list()
        })
}
